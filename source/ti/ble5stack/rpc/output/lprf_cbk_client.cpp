/*
 * Generated by erpcgen 1.7.3 on Tue Jan  5 17:50:11 2021.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#include "erpc_client_manager.h"
#include "erpc_port.h"
#include "erpc_codec.h"
extern "C"
{
#include "lprf_cbk.h"
// import callbacks declaration from other groups
#include "lprf_api.h"
}

#if 10703 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

using namespace erpc;
using namespace std;

//extern ClientManager *g_client;
ClientManager *lprf_cbk_cm;

//! @brief Function to write struct bt_mesh_msg_ctx_raw
static void write_bt_mesh_msg_ctx_raw_struct(erpc::Codec * codec, const bt_mesh_msg_ctx_raw * data);

//! @brief Function to write struct net_buf_simple_raw
static void write_net_buf_simple_raw_struct(erpc::Codec * codec, const net_buf_simple_raw * data);


// Write struct bt_mesh_msg_ctx_raw function implementation
static void write_bt_mesh_msg_ctx_raw_struct(erpc::Codec * codec, const bt_mesh_msg_ctx_raw * data)
{
    codec->write(data->net_idx);

    codec->write(data->app_idx);

    codec->write(data->addr);

    codec->write(data->recv_dst);

    codec->write(data->recv_rssi);

    codec->write(data->recv_ttl);

    codec->write(data->send_rel);

    codec->write(data->send_ttl);
}

// Write struct net_buf_simple_raw function implementation
static void write_net_buf_simple_raw_struct(erpc::Codec * codec, const net_buf_simple_raw * data)
{
    codec->startWriteList(data->len);
    for (uint32_t listCount0 = 0; listCount0 < data->len; ++listCount0)
    {
        codec->write(data->data[listCount0]);
    }

    codec->write(data->size);

    codec->write(*data->__buf);
}



// BLEmesh_cbk_access interface settings_commit_cb function client shim.
void settings_commit_cb(uint16_t elem_idx, uint8_t is_vnd, uint16_t model_index)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_access_service_id, kBLEmesh_cbk_access_settings_commit_cb_id, request.getSequence());

        codec->write(elem_idx);

        codec->write(is_vnd);

        codec->write(model_index);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_access_settings_commit_cb_id);

    return;
}

// BLEmesh_cbk_access interface init_cb function client shim.
void init_cb(uint16_t elem_idx, uint8_t is_vnd, uint16_t model_index)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_access_service_id, kBLEmesh_cbk_access_init_cb_id, request.getSequence());

        codec->write(elem_idx);

        codec->write(is_vnd);

        codec->write(model_index);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_access_init_cb_id);

    return;
}

// BLEmesh_cbk_access interface reset_cb function client shim.
void reset_cb(uint16_t elem_idx, uint8_t is_vnd, uint16_t model_index)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_access_service_id, kBLEmesh_cbk_access_reset_cb_id, request.getSequence());

        codec->write(elem_idx);

        codec->write(is_vnd);

        codec->write(model_index);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_access_reset_cb_id);

    return;
}

// BLEmesh_cbk_access interface update_cb function client shim.
void update_cb(uint16_t elem_idx, uint8_t is_vnd, uint16_t model_index)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_access_service_id, kBLEmesh_cbk_access_update_cb_id, request.getSequence());

        codec->write(elem_idx);

        codec->write(is_vnd);

        codec->write(model_index);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_access_update_cb_id);

    return;
}

// BLEmesh_cbk_access interface func_cb function client shim.
void func_cb(uint32_t opcode, uint16_t elem_idx, uint8_t is_vnd, uint16_t model_index, bt_mesh_msg_ctx_raw * ctx, net_buf_simple_raw * buf)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_access_service_id, kBLEmesh_cbk_access_func_cb_id, request.getSequence());

        codec->write(opcode);

        codec->write(elem_idx);

        codec->write(is_vnd);

        codec->write(model_index);

        codec->startWriteList(1);
        for (uint32_t listCount0 = 0; listCount0 < 1; ++listCount0)
        {
            write_bt_mesh_msg_ctx_raw_struct(codec, &(ctx[listCount0]));
        }

        codec->startWriteList(1);
        for (uint32_t listCount1 = 0; listCount1 < 1; ++listCount1)
        {
            write_net_buf_simple_raw_struct(codec, &(buf[listCount1]));
        }

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_access_func_cb_id);

    return;
}

// BLEmesh_cbk_access interface hb_sub_cb function client shim.
void hb_sub_cb(uint8_t hops, uint16_t feat)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_access_service_id, kBLEmesh_cbk_access_hb_sub_cb_id, request.getSequence());

        codec->write(hops);

        codec->write(feat);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_access_hb_sub_cb_id);

    return;
}

// BLEmesh_cbk_health_srv interface fault_get_cur_cb function client shim.
int32_t fault_get_cur_cb(uint16_t elem_idx, uint16_t model_index, uint8_t * test_id, uint16_t * company_id, uint8_t * faults, uint8_t * fault_count)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kBLEmesh_cbk_health_srv_service_id, kBLEmesh_cbk_health_srv_fault_get_cur_cb_id, request.getSequence());

        codec->write(elem_idx);

        codec->write(model_index);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        codec->read(test_id);

        codec->read(company_id);

        uint32_t lengthTemp_0;
        codec->startReadList(&lengthTemp_0);
        *fault_count = lengthTemp_0;
        if (lengthTemp_0 <= 256)
        {
            for (uint32_t listCount0 = 0; listCount0 < lengthTemp_0; ++listCount0)
            {
                codec->read(&faults[listCount0]);
            }
        }
        else
        {
            codec->updateStatus(kErpcStatus_Fail);
        }

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_health_srv_fault_get_cur_cb_id);

    if (err)
    {
        return -1;
    }

    return result;
}

// BLEmesh_cbk_health_srv interface fault_get_reg_cb function client shim.
int32_t fault_get_reg_cb(uint16_t elem_idx, uint16_t model_index, uint16_t company_id, uint8_t * test_id, uint8_t * faults, uint8_t * fault_count)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kBLEmesh_cbk_health_srv_service_id, kBLEmesh_cbk_health_srv_fault_get_reg_cb_id, request.getSequence());

        codec->write(elem_idx);

        codec->write(model_index);

        codec->write(company_id);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        codec->read(test_id);

        uint32_t lengthTemp_0;
        codec->startReadList(&lengthTemp_0);
        *fault_count = lengthTemp_0;
        if (lengthTemp_0 <= 256)
        {
            for (uint32_t listCount0 = 0; listCount0 < lengthTemp_0; ++listCount0)
            {
                codec->read(&faults[listCount0]);
            }
        }
        else
        {
            codec->updateStatus(kErpcStatus_Fail);
        }

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_health_srv_fault_get_reg_cb_id);

    if (err)
    {
        return -1;
    }

    return result;
}

// BLEmesh_cbk_health_srv interface fault_clear_cb function client shim.
int32_t fault_clear_cb(uint16_t elem_idx, uint16_t model_index, uint16_t company_id)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kBLEmesh_cbk_health_srv_service_id, kBLEmesh_cbk_health_srv_fault_clear_cb_id, request.getSequence());

        codec->write(elem_idx);

        codec->write(model_index);

        codec->write(company_id);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_health_srv_fault_clear_cb_id);

    if (err)
    {
        return -1;
    }

    return result;
}

// BLEmesh_cbk_health_srv interface fault_test_cb function client shim.
int32_t fault_test_cb(uint16_t elem_idx, uint16_t model_index, uint8_t test_id, uint16_t company_id)
{
    erpc_status_t err = kErpcStatus_Success;

    int32_t result;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kBLEmesh_cbk_health_srv_service_id, kBLEmesh_cbk_health_srv_fault_test_cb_id, request.getSequence());

        codec->write(elem_idx);

        codec->write(model_index);

        codec->write(test_id);

        codec->write(company_id);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_health_srv_fault_test_cb_id);

    if (err)
    {
        return -1;
    }

    return result;
}

// BLEmesh_cbk_health_srv interface attn_on_cb function client shim.
void attn_on_cb(uint16_t elem_idx, uint16_t model_index)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_health_srv_service_id, kBLEmesh_cbk_health_srv_attn_on_cb_id, request.getSequence());

        codec->write(elem_idx);

        codec->write(model_index);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_health_srv_attn_on_cb_id);

    return;
}

// BLEmesh_cbk_health_srv interface attn_off_cb function client shim.
void attn_off_cb(uint16_t elem_idx, uint16_t model_index)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_health_srv_service_id, kBLEmesh_cbk_health_srv_attn_off_cb_id, request.getSequence());

        codec->write(elem_idx);

        codec->write(model_index);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_health_srv_attn_off_cb_id);

    return;
}

// BLEmesh_cbk interface output_number_cb function client shim.
void output_number_cb(bt_mesh_output_action act, uint32_t num)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_output_number_cb_id, request.getSequence());

        codec->write(static_cast<int32_t>(act));

        codec->write(num);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_output_number_cb_id);

    return;
}

// BLEmesh_cbk interface output_string_cb function client shim.
void output_string_cb(const char * str)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_output_string_cb_id, request.getSequence());

        codec->writeString(strlen(str), str);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_output_string_cb_id);

    return;
}

// BLEmesh_cbk interface input_cb function client shim.
void input_cb(bt_mesh_input_action act, uint8_t size)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_input_cb_id, request.getSequence());

        codec->write(static_cast<int32_t>(act));

        codec->write(size);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_input_cb_id);

    return;
}

// BLEmesh_cbk interface input_complete_cb function client shim.
void input_complete_cb(void)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_input_complete_cb_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_input_complete_cb_id);

    return;
}

// BLEmesh_cbk interface unprovisioned_beacon_cb function client shim.
void unprovisioned_beacon_cb(uint8_t uuid[16], bt_mesh_prov_oob_info oob_info, uint32_t * uri_hash)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_unprovisioned_beacon_cb_id, request.getSequence());

        for (uint32_t arrayCount0 = 0; arrayCount0 < 16; ++arrayCount0)
        {
            codec->write(uuid[arrayCount0]);
        }

        codec->write(static_cast<int32_t>(oob_info));

        codec->startWriteList(1);
        for (uint32_t listCount0 = 0; listCount0 < 1; ++listCount0)
        {
            codec->write(uri_hash[listCount0]);
        }

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_unprovisioned_beacon_cb_id);

    return;
}

// BLEmesh_cbk interface link_open_cb function client shim.
void link_open_cb(bt_mesh_prov_bearer bearer)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_link_open_cb_id, request.getSequence());

        codec->write(static_cast<int32_t>(bearer));

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_link_open_cb_id);

    return;
}

// BLEmesh_cbk interface link_close_cb function client shim.
void link_close_cb(bt_mesh_prov_bearer bearer)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_link_close_cb_id, request.getSequence());

        codec->write(static_cast<int32_t>(bearer));

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_link_close_cb_id);

    return;
}

// BLEmesh_cbk interface complete_cb function client shim.
void complete_cb(uint16_t net_idx, uint16_t addr)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_complete_cb_id, request.getSequence());

        codec->write(net_idx);

        codec->write(addr);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_complete_cb_id);

    return;
}

// BLEmesh_cbk interface node_added_cb function client shim.
void node_added_cb(uint16_t net_idx, uint16_t addr, uint8_t num_elem)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_node_added_cb_id, request.getSequence());

        codec->write(net_idx);

        codec->write(addr);

        codec->write(num_elem);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_node_added_cb_id);

    return;
}

// BLEmesh_cbk interface reset_prov_cb function client shim.
void reset_prov_cb(void)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_reset_prov_cb_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_reset_prov_cb_id);

    return;
}

// BLEmesh_cbk interface lpn_set_cb function client shim.
void lpn_set_cb(uint16_t friend_addr, bool established)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = lprf_cbk_cm->createRequest(true);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kOnewayMessage, kBLEmesh_cbk_service_id, kBLEmesh_cbk_lpn_set_cb_id, request.getSequence());

        codec->write(friend_addr);

        codec->write(established);

        // Send message to server
        // Codec status is checked inside this function.
        lprf_cbk_cm->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    lprf_cbk_cm->releaseRequest(request);

    // Invoke error handler callback function
    lprf_cbk_cm->callErrorHandler(err, kBLEmesh_cbk_lpn_set_cb_id);

    return;
}
