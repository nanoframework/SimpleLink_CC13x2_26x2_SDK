/*
 * Copyright (c) 2019 Texas Instruments Incorporated - http://www.ti.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 *  ======== easylink_rf_config.syscfg.js ========
 */

"use strict";

// Get common utility functions
const Common = system.getScript("/ti/easylink/easylink_common.js");

// Get RF Setting long descriptions
const docs = system.getScript("/ti/easylink/rf_config/"
    + "easylink_rf_config_docs.js");

// Get the RF defaults for the LaunchPad or device being used
const propPhySettings = system.getScript("/ti/easylink/rf_config/"
    + Common.getBoardOrLaunchPadName(true)
    + "_rf_defaults.js").defaultPropPhyList;

const customPhyName = "EasyLink_Phy_Custom";

// Configurables for the EasyLink RF Configuration module
const config = getAllPhyConfigurables();

// Add default phy as the last in the list
config.push({
    name: "defaultPhy",
    displayName: "Default PHY",
    description: "The default PHY modulation to be used when "
        + "EasyLink_init() is called",
    longDescription: docs.defaultPhyLongDescription,
    getDisabledOptions: generateDisabledOptions(),
    options: getBoardEasyLinkRfOptions(), // Phy options differ b/w devices
    default: customPhyName // All devices have a custom phy option
});

// Add configurable as the first in the list
config.splice(0, 0, {
    name: "configInSrfStudio",
    displayName: "Use RF Settings Exported from SmartRF Studio",
    description: "Do not generate RF settings via SysConfig",
    longDescription: docs.configInSrfStudioLongDescription,
    default: false,
    onChange: onConfigInSrfStudioChange
});

/*
 *  ======== getAllPhyConfigurables ========
 *  Creates an array of all the device specific PHYs in valid SysConfig config
 *  format for a checkbox.
 *
 * @returns Array - array of check-boxes
 */
function getAllPhyConfigurables()
{
    const options = getBoardEasyLinkRfOptions(); // Get board specific options

    return(_.map(options, phy => ({
        name: phy.name,
        displayName: phy.displayName,
        onChange: onPhyConfigChange,
        default: phy.name === customPhyName,
        readOnly: phy.name === customPhyName
    })));
}

/*
 *  ======== generateDropDownOptions ========
 *  Generates a list of options that should be disabled in the defaultPhy
 *  drop-down
 *
 * @returns Array - array of strings that should be disabled
 */
function generateDisabledOptions()
{
    return inst => getEnabledOrDisabledOptions(inst, false);
}

/*
 *  ======== getEnabledOrDisabledOptions ========
 *  Generates an array of the currently selected or deselected device specific
 *  PHYs
 *
 * @param inst - Instance of this module
 * @param enabledMask - Boolean, True = return enabled list, False = return
 *                      disabled list
 *
 * @returns Array - Array of the names of the PHYs enabled or disabled depending
 *                  on the value of enabledMask
 */
function getEnabledOrDisabledOptions(inst, enabledMask)
{
    const options = [];

    // Only generate the list of the settings are being generated by SysConfig
    if(!inst.configInSrfStudio)
    {
        // Find the configurable we're going to generate a disabled list from
        const phyList = getAllPhyConfigurables();

        // Iterate over all the possible phy's
        let phy = null;
        for(phy of phyList)
        {
            // Check if state of PHY is the same as the list being requested
            if(inst[phy.name] === enabledMask)
            {
                options.push({
                    name: phy.name,
                    reason: "Not an enabled PHY"
                });
            }
        }
    }

    return(options);
}

/*
 *  ======== onPhyConfigChange ========
 *  Ensures at least one PHY is selected/enabled at all times. Also ensures that
 *  the defaultPhy will always be set to a selected/enabled PHY
 *
 * @param inst  - Module instance containing the config that changed
 * @param ui    - The User Interface object
 */
function onPhyConfigChange(inst, ui)
{
    // Get a list of the phys that are currently enabled
    const enabledPhys = getEnabledOrDisabledOptions(inst, true);
    let defaultPhyIsValid = false;

    /*
     * Need to ensure at least 1 phy is selected/enabled at all times. This is
     * done with the following logic:
     *     - If more than 1 phy is selected/enabled, unlock all phys
     *     - If only 1 phy is selected, lock that selection leaving the others
     *       unlocked
     */
    if(enabledPhys.length > 1)
    { // More than 1 PHY selected, unlock all PHYs
        let phy = null;
        for(phy of enabledPhys)
        {
            ui[phy.name].readOnly = false;
            if(phy.name === inst.defaultPhy)
            {
                defaultPhyIsValid = true;
            }
        }
    }
    else
    { // Only 1 PHY selected, lock that selection
        ui[enabledPhys[0].name].readOnly = true;
        if(enabledPhys[0].name === inst.defaultPhy)
        {
            defaultPhyIsValid = true;
        }
    }

    // If the defaultPhy is no longer enabled, set it to the first enabled PHY
    if(!defaultPhyIsValid)
    {
        inst.defaultPhy = enabledPhys[0].name;
    }
}

/*
 *  ======== onConfigInSrfStudioChange ========
 *  Enables or disables phy configuration
 *
 * @param inst  - Module instance containing the config that changed
 * @param ui    - The User Interface object
 */
function onConfigInSrfStudioChange(inst, ui)
{
    const phyList = getAllPhyConfigurables();

    let phy = null;
    for(phy of phyList)
    {
        ui[phy.name].hidden = inst.configInSrfStudio;
    }

    if(inst.configInSrfStudio)
    {
        // Set the default and supported phys to custom
        inst.defaultPhy = customPhyName;

        // Disable the ability to configure phy settings via SysConfig
        ui.defaultPhy.readOnly = true;
    }
    else
    {
        // Allow the user to configure phy settings via SysConfig
        ui.defaultPhy.readOnly = false;
    }
}

/*
 *  ======== getBoardEasyLinkRfOptions ========
 *  Retrieves the board/devices rfSettings from the <board_name>_rf_defaults.js
 *  file and returns an options array for the Easylink stack
 *
 *  @returns Array - an array containing one or more dictionaries with the
 *                   following keys: displayName, name
 *
 */
function getBoardEasyLinkRfOptions()
{
    const ezPhys = _.filter(propPhySettings, phy => ("easyLinkOption" in phy));

    // Construct the options array
    const options = _.map(ezPhys, phy => phy.easyLinkOption);

    // Add the custom phy option, regardless of device
    options.splice(0, 0, {
        name: customPhyName,
        displayName: "Custom"
    });

    return(options);
}

/*
 *  ======== addRfSettingDependency ========
 *  Creates an RF setting dependency module
 *
 * @param easyLinkPhyType  - EasyLink enum representation of the phy type
 * @returns dictionary - containing a single RF setting dependency module
 */
function addRfSettingDependency(easyLinkPhyType)
{
    let radioConfigArgs = {};
    let displayName = "Custom";
    const radioConfigVarName = Common.underscoreToCamelCase(easyLinkPhyType);

    // If the PHY is custom, find the first PHY that has EasyLink support
    if(easyLinkPhyType === customPhyName)
    {
        let basePhy = _.find(propPhySettings, i => ("easyLinkOption" in i));

        // Cover the case when there is no supported easylink phy
        if(basePhy === undefined)
        {
            basePhy = {args: {}};
        }

        // When creating a custom PHY, these settings persist from base PHY
        const customPhyWhiteList = ["useMulti", "paExport", "cmdList_prop"];

        // Get the settings from the base phy
        radioConfigArgs = _.cloneDeep(basePhy.args);
        radioConfigArgs.codeExportConfig = {};

        const baseCodeExport = basePhy.args.codeExportConfig;

        // Extract the whitelist settings from the base PHY
        let key = null;
        for(key in basePhy.args.codeExportConfig)
        {
            if(customPhyWhiteList.includes(key))
            {
                radioConfigArgs.codeExportConfig[key] = baseCodeExport[key];
            }
        }

        radioConfigArgs.codeExportConfig.symGenMethod = "Legacy";
        radioConfigArgs.$name = "EasyLink_RF_Custom_Setting";
        radioConfigArgs.permission = "ReadWrite";
    }
    else
    {
        // Not a custom PHY
        const phy = _.find(propPhySettings, i => (("easyLinkOption" in i)
            && (i.easyLinkOption.name === easyLinkPhyType)));

        radioConfigArgs = _.cloneDeep(phy.args);
        radioConfigArgs.$name = "EasyLink_" + radioConfigArgs.$name;
        radioConfigArgs.permission = "ReadOnly";
        displayName = phy.easyLinkOption.displayName;
    }

    // All EasyLink Phys use a variable packet length
    radioConfigArgs.packetLengthConfig = "Variable";

    return({
        name: "radioConfig" + radioConfigVarName,
        displayName: displayName + " Radio Settings",
        moduleName: "/ti/radioconfig/settings/prop",
        collapsed: true,
        args: radioConfigArgs
    });
}

/*
 *  ======== moduleInstances ========
 *  Determines what modules are added as non-static sub-modules
 *
 *  @param inst  - Module instance containing the config that changed
 *  @returns     - Array containing dependency modules
 */
function moduleInstances(inst)
{
    const dependencyModule = [];

    if(!inst.configInSrfStudio)
    {
        const phyList = getAllPhyConfigurables();

        let phy = null;
        for(phy of phyList)
        {
            if(inst[phy.name])
            {
                dependencyModule.push(addRfSettingDependency(phy.name));
            }
        }
    }

    return(dependencyModule);
}

/*
 * ======== validate ========
 * Validate this inst's configuration
 *
 * @param inst       - RF Settings instance to be validated
 * @param validation - object to hold detected validation issues
 */
function validate(inst, validation)
{
    let enabledPhys = [];
    const board = Common.getBoardOrLaunchPadName(true);

    // Get a list of the phys that are currently enabled
    if(!inst.configInSrfStudio)
    {
        enabledPhys = getEnabledOrDisabledOptions(inst, true);
    }

    // Iterate over all the enabled phys verifying the code export settings
    let phy = null;
    for(phy of enabledPhys)
    {
        // Get the radio config instance for the phy
        const rcName = "radioConfig" + Common.underscoreToCamelCase(phy.name);
        const radioConfigInst = inst[rcName];

        // If this is a P board, need to check for PA settings
        if(board.includes("CC1352P"))
        {
            // Verify combined PA table
            if(radioConfigInst.codeExportConfig.paExport !== "combined")
            {
                validation.logError("EasyLink stack requires a Combined PA "
                    + "Table", radioConfigInst.codeExportConfig, "paExport");
            }

            // Verify div setup PA command
            if(!radioConfigInst.codeExportConfig.cmdList_prop.includes(
                "cmdPropRadioDivSetupPa"
            ))
            {
                validation.logError("EasyLink stack requires the "
                    + "CMD_PROP_RADIO_DIV_SETUP_PA command",
                radioConfigInst.codeExportConfig, "cmdList_prop");
            }
        }
        else
        { // Not a P board, don't check for P settings
            // Verify radio div setup
            if(!radioConfigInst.codeExportConfig.cmdList_prop.includes(
                "cmdPropRadioDivSetup"
            ))
            {
                validation.logError("EasyLink stack requires the "
                    + "CMD_PROP_RADIO_DIV_SETUP command",
                radioConfigInst.codeExportConfig, "cmdList_prop");
            }

            // Verify active PA table
            if(radioConfigInst.codeExportConfig.paExport !== "active")
            {
                validation.logError("EasyLink stack requires an Active PA "
                    + "Table", radioConfigInst.codeExportConfig, "paExport");
            }
        }

        // If using IEEE 15.4 PHY check for TX Adv command
        if(radioConfigInst["phyType"
            + radioConfigInst.freqBand].includes("154g"))
        {
            if(!radioConfigInst.codeExportConfig.cmdList_prop.includes(
                "cmdPropTxAdv"
            ))
            {
                validation.logError("EasyLink stack requires the "
                    + "CMD_PROP_TX_ADV command",
                radioConfigInst.codeExportConfig, "cmdList_prop");
            }
        }
        else if(!radioConfigInst.codeExportConfig.cmdList_prop.includes(
            "cmdPropTx"
        ))
        { // Not using IEEE 15.4 PHY, verify Tx command
            validation.logError("EasyLink stack requires the CMD_PROP_TX "
                + "command", radioConfigInst.codeExportConfig, "cmdList_prop");
        }

        // Verify the Rx Adv command
        if(!radioConfigInst.codeExportConfig.cmdList_prop.includes(
            "cmdPropRxAdv"
        ))
        {
            validation.logError("EasyLink stack requires the CMD_PROP_RX_ADV "
                + "command", radioConfigInst.codeExportConfig, "cmdList_prop");
        }

        // Verify the FS command
        if(!radioConfigInst.codeExportConfig.cmdList_prop.includes("cmdFs"))
        {
            validation.logError("EasyLink stack requires the CMD_FS command",
                radioConfigInst.codeExportConfig, "cmdList_prop");
        }
    }
}

/*
 *  ======== rfConfig ========
 *  Define the EasyLink rfConfig properties and methods
 */
const rfConfig = {
    displayName: "EasyLink RF Settings",
    config: config,
    validate: validate,
    moduleInstances: moduleInstances
};

exports = rfConfig;
